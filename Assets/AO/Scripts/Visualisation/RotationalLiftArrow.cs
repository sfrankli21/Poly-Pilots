using AerodynamicObjects.Aerodynamics;
using UnityEngine;

namespace AerodynamicObjects
{
    /// <summary>
    /// Creates an arrow with scale and direction proportional to the rotational lift force generated by an AeroObject's Rotational Lift Model.
    /// </summary>
    [AddComponentMenu("Aerodynamic Objects/Visualisation/Rotational Lift Arrow")]
    public class RotationalLiftArrow : ArrowComponent
    {
        AeroObject aeroObject;
        Arrow arrow;
        public int modelIndex;
        RotationalLiftModel model;
        public Color colour = new Color(78f / 255f, 224f / 255f, 62f / 255f, 0.5f);

        void OnEnable()
        {
            aeroObject = TryGetAeroObject();
            model = aeroObject.GetModel<RotationalLiftModel>();

            if (model == null)
            {
                Debug.LogWarning("No rotational lift model was found for the rotational lift arrow component on " + name + ". Destroying the arrow component.");
                Destroy(this);
                return;
            }

            modelIndex = aeroObject.GetModelIndex<RotationalLiftModel>();
            arrow = new Arrow(colour, "Rotational Lift Arrow");
        }

        void Update()
        {
            if (UseCoefficientForScale)
            {
                // Need to use the absolute value of the coefficient because we already have the direction from the force
                SetArrowPositionAndRotationFromVector(arrow, aeroObject.transform.TransformDirection(Vector3.Cross(Vector3.Scale(aeroObject.localAngularVelocity.normalized, model.dimensionScale), aeroObject.localRelativeVelocity.normalized)), aeroObject.transform.position);
            }
            else
            {
                SetArrowPositionAndRotationFromVector(arrow, aeroObject.transform.TransformDirection(aeroObject.aerodynamicLoads[modelIndex].force), aeroObject.transform.position);
            }
        }

        public override void CleanUp()
        {
            arrow?.DestroyArrow();
        }
    }
}
