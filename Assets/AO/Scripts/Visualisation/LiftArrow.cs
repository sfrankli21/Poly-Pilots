using AerodynamicObjects.Aerodynamics;
using UnityEngine;

namespace AerodynamicObjects
{
    /// <summary>
    /// Creates an arrow with scale and direction proportional to the lift force generated by an AeroObject's Lift Model.
    /// </summary>
    [AddComponentMenu("Aerodynamic Objects/Visualisation/Lift Arrow")]
    public class LiftArrow : ArrowComponent
    {
        AeroObject aeroObject;
        Arrow arrow;
        int modelIndex;
        LiftModel model;
        public Color colour = new Color(78f / 255f, 224f / 255f, 62f / 255f, 0.5f);

        void OnEnable()
        {
            aeroObject = TryGetAeroObject();
            model = aeroObject.GetModel<LiftModel>();

            if (model == null)
            {
                Debug.LogWarning("No lift model was found for the lift arrow component on " + name + ". Destroying the lift arrow component.");
                Destroy(this);
                return;
            }

            modelIndex = aeroObject.GetModelIndex<LiftModel>();
            arrow = new Arrow(colour, "Lift Arrow");
        }

        Vector3 aerodynamicCentre;
        Vector3 liftEarthFrame;
        void Update()
        {
            // Get the lift force in the earth frame
            liftEarthFrame = aeroObject.transform.TransformDirection(aeroObject.aerodynamicLoads[modelIndex].force);

            // ===============================================
            // Draw the arrow at the aerodynamic centre!!!
            // ===============================================

            // Get the AC in body coordinates, using sideslip then convert to object (Unity's local) frame
            aerodynamicCentre = model.TransformBodyToLocal(new Vector3(model.aerodynamicCentre_z * model.sinBeta, 0, model.aerodynamicCentre_z * model.cosBeta));
            aerodynamicCentre = aeroObject.transform.position + aeroObject.transform.TransformDirection(aerodynamicCentre);

            if (UseCoefficientForScale)
            {
                // This isn't a perfect representation because we're ignoring the CDi present in the force as well
                SetArrowPositionAndRotationFromVector(arrow, model.CL * liftEarthFrame.normalized, aerodynamicCentre);
            }
            else
            {
                SetArrowPositionAndRotationFromVector(arrow, liftEarthFrame, aerodynamicCentre);
            }
        }

        public override void CleanUp()
        {
            arrow?.DestroyArrow();
        }
    }
}
