using AerodynamicObjects.Flow;
using UnityEngine;

namespace AerodynamicObjects.Demos
{
    /// <summary>
    /// Used to manage the vortex filament strengths in the ring vortex generated by a helicopter's main rotor.
    /// </summary>
    public class HelicopterRingVortexController : MonoBehaviour
    {
        /// <summary>
        /// The top level transforms of the three rotor blades on the helicopter.
        /// </summary>
        [Tooltip("The top level transforms of the three rotor blades on the helicopter.")]
        public Transform blade1, blade2, blade3;
        Transform bladeTip1, bladeTip2, bladeTip3;
        //FluidVolume fluidVolume; 
        AeroObject ao1; //ao for first blade used for load estimation
        public AeroObject[] vehicleAOs; // aos for the whole helicopter - dont know in what order.
        public float strengthMultiplier;
        RingVortex ringVortex;
        Vector3 AB, AC, tipPlaneNormal;
        float strength;
        void Start()
        {
            ringVortex = GetComponent<RingVortex>();
            bladeTip1 = blade1.Find("Blade tip");
            bladeTip2 = blade2.Find("Blade tip");
            bladeTip3 = blade3.Find("Blade tip");
            vehicleAOs = transform.parent.GetComponentsInChildren<AeroObject>();
            //fluidVolume = GetComponent<FluidVolume>();
            ao1 = blade1.GetComponentInChildren<AeroObject>();

            foreach (AeroObject ao in vehicleAOs)
            {
                foreach (VortexFilament vortexFilament in ringVortex.filaments)
                {
                    ao.IgnoreInteraction(vortexFilament);
                }
            }
        }

        void FixedUpdate()
        {
            //set the height of the centre point to the average height of the blade tips
            transform.position = new Vector3(transform.position.x, (bladeTip1.position.y + bladeTip2.position.y + bladeTip3.position.y) / 3f, transform.position.z);
            //set the rotation so that the vortex ring is in the tip plane of the rotor
            AB = (bladeTip1.position - bladeTip2.position).normalized;
            AC = (bladeTip1.position - bladeTip3.position).normalized;
            tipPlaneNormal = Vector3.Cross(AB, AC);
            transform.rotation = Quaternion.FromToRotation(Vector3.forward, tipPlaneNormal); // starting orientation of vortex ring is normal facing forward

            // get aerodynamic load on rotor from blade aerobodies
            strength = -strengthMultiplier * ao1.netAerodynamicLoad.force.y; // using the blade aerodynamic force from ONE blade as a proxy for overall lift
                                                                             //update the filament strengths individually (not implemented on RingVortex)
            for (int i = 0; i < ringVortex.filaments.Length; i++)
            {
                ringVortex.filaments[i].initialStrength = strength;
            }
        }
    }
}
